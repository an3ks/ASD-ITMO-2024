# Отчет по улучшенной версии быстрой сортировки (Quick Sort)

## Задание

Реализовать улучшенную версию алгоритма быстрой сортировки с гибридным подходом, использующим сортировку вставками для
небольших подмассивов и случайный выбор опорного элемента.

## Реализация

Для повышения производительности алгоритма Quick Sort был использован гибридный подход, который сочетает обычную быструю
сортировку и сортировку вставками для небольших подмассивов (меньше 10 элементов). Это позволило снизить общие затраты
времени при сортировке коротких подсписков.

Компоненты реализации:

- Для подсписков размером меньше 10 элементов была использована сортировка вставками.
- Для выбора опорного элемента при каждом разделении был использован случайный выбор, что снизило возможность неудачного
  разделения и повлияло на лучшую среднюю скорость выполнения.

## Input / Output

- **Input:** 9, 7, 5, 11, 12, 2, 14, 3, 10, 6
- **Output:** 2, 3, 5, 6, 7, 9, 10, 11, 12, 14

## Потребление времени и памяти

- Ограничение по времени: 2 сек.
- Ограничение по памяти: 256 Мб

Время выполнения алгоритма на наборе данных входных данных было около 0.03 секунды, а пиковое потребление памяти не
превысило 150 Мб.

## Запуск проекта

1. Клонируйте репозиторий:
   ```bash
   git clone https://github.com/an3ks/ASD-ITMO-2024
   ```
2. Перейдите в папку с проектом:
   ```bash
   cd lab3/task4/src
   ```
3. Запустите программу:
   ```bash
   python ex4.py
   ```

## Тестирование

Для запуска тестов выполните:

```bash
python -m unittest discover test/
```

## Код для def lottery()

```python
def lottery(data):
    # Распаковка входных данных
    s, p = data[0]  # количество отрезков и точек
    array = data[1:s + 1]  # список всех списков
    dot_list = data[s + 1]  # список всех точек

    events = []

    for ul in array:
        events.append((ul[0], -1))
        events.append((ul[-1], 1))  # добавили конец и начало каждого отрезка, пометив их индексами -1 и 1

    for idx, dot in enumerate(dot_list):
        events.append((dot, 0, idx))

    events = sorted(events, key=lambda x: (x[0], x[1]))
    cntr = 0
    list_peresecheniy = []
    for event in events:
        if event[1] == -1:
            cntr += 1
        elif event[1] == 1:
            cntr -= 1
        elif event[1] == 0:
            list_peresecheniy.append((cntr, event[2]))
    list_peresecheniy = sorted(list_peresecheniy, key=lambda x: x[1])
    result = [count for count, _ in list_peresecheniy]
    return result


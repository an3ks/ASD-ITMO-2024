# Задание по реализации алгоритма сортировки слиянием с логированием индексов

Студент ИТМО, Авдиенко Данила, itmoId 464919

## Описание задания
Реализовать алгоритм сортировки слиянием (Merge Sort) для сортировки массива данных. В процессе выполнения сортировки необходимо логировать индексы начала и конца объединенного подмассива и значения его первого и последнего элементов.

## Реализация алгоритма
Алгоритм сортировки слиянием был реализован с использованием Python. Основная идея заключается в следующем:
- Рекурсивное деление массива на левую и правую части до тех пор, пока каждая часть не станет содержать по одному элементу.
- Слияние и сортировка двух частей в один отсортированный массив.
- Логирование индексов начала и конца объединенного подмассива и значений первого и последнего элементов для отслеживания изменений на каждом шаге слияния.

### Input / Output

| Input                      | Output                                |
|----------------------------|---------------------------------------|
| [9, 7, 5, 11, 12, 2, 14, 3, 10, 6] | [2, 3, 5, 6, 7, 9, 10, 11, 12, 14] |

## Ограничения по времени и памяти

- Ограничение по времени: 2 сек.
- Ограничение по памяти: 256 Мб.

## Запуск проекта
1. Клонируйте репозиторий:
   ```bash
   git clone https://github.com/an3ks/ASD-ITMO-2024
   ```
2. Перейдите в папку с проектом:
   ```bash
   cd lab2/task2/src
   ```
3. Запустите программу:
   ```bash
   python second.py
   ```

## Тестирование
Для запуска тестов выполните:
```bash
python -m unittest discover test/
```

## Код для main.py
```python
import time
import resource
from lab2.utils import write_output, read_input, time_memory_tracking


def merge_sort(arr: list, index_log: list, start_idx=0):
    if len(arr) > 1:  # проверяем, не является ли длина массива единицей
        l = arr[:len(arr) // 2]  # делим текущий массив на две части
        r = arr[len(arr) // 2:]
        # рекурсивно вызываем функцию на каждую из частей, пока она внутри не дойдет до условия, что длина == 1 и не начнет выполнять код ниже
        merge_sort(l, index_log, start_idx)
        merge_sort(r, index_log, start_idx + len(l))
        templist = []  # временный список для слияния двух частей
        i = j = 0  # задаем индексы для работы с массивами
        while len(l) > i and len(r) > j:  # условие для прекращения (пока индекс сравниваемого элемента не станет равным длине списка)
            if l[i] <= r[j]:  # сравнение
                templist.append(l[i])
                i += 1
            else:
                templist.append(r[j])
                j += 1
        if len(l) == i:  # если мы подошли к концу списка л, то добавляем все элементы списка р и наоборот в елсе
            templist.extend(r[j:])
        else:
            templist.extend(l[i:])

        # Записываем индексы начала и конца объединенного списка и значения
        first_idx = start_idx
        last_idx = start_idx + len(templist) - 1
        index_log.append((first_idx + 1, last_idx + 1, templist[0], templist[-1]))  # +1 для человеческого индекса

        for i in range(len(templist)):  # обновляем исходный лист
            arr[i] = templist[i]


if __name__ == "__main__":
    time_start = time.perf_counter()
    n, arr = read_input("../txtf/input.txt")
    index_log = []  # Хранение индексов и значений для каждой итерации слияния
    merge_sort(arr, index_log)
    write_output(arr, "../txtf/output.txt", index_log)
    time_memory_tracking(time_start)
```

## Результаты

- **Время выполнения:** Время выполнения программы измерялось с помощью модуля `time` и составляет менее 2 секунд для тестовых данных.
- **Использование памяти:** Пиковое потребление памяти не превышает 256 Мб.

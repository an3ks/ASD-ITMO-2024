# Задание по реализации алгоритма поиска элемента большинства

Студент ИТМО, Авдиенко Данила, itmoId 464919

## Описание задания
Реализовать алгоритм для поиска элемента большинства (элемент, который встречается более чем в половине случаев) в массиве. Алгоритм должен возвращать 1, если такой элемент существует, и 0, если его нет.

## Реализация алгоритма
Алгоритм был реализован с использованием Python и основывается на методе "разделяй и властвуй":
- Массив рекурсивно делится на две половины до тех пор, пока не остается один элемент.
- Затем вычисляется элемент большинства для каждой из половин и проверяется, какой из них (если такой имеется) является элементом большинства в текущем объединенном массиве.
- Алгоритм возвращает 1, если существует элемент, который встречается в массиве более чем в половине случаев.

### Input / Output

| Input                      | Output                                |
|----------------------------|---------------------------------------|
| [2, 3, 9, 2, 2],           | 1                                     |
| [1, 2, 3, 4, 5],           | 0                                     |

## Ограничения по времени и памяти

- Ограничение по времени: 2 сек.
- Ограничение по памяти: 256 Мб.

## Запуск проекта
1. Клонируйте репозиторий:
   ```bash
   git clone https://github.com/an3ks/ASD-ITMO-2024
   ```
2. Перейдите в папку с проектом:
   ```bash
   cd lab2/task5/src
   ```
3. Запустите программу:
   ```bash
   python fifth.py
   ```

## Тестирование
Для запуска тестов выполните:
```bash
python -m unittest discover test/
```

## Код для main.py
```python
import time
import resource
from lab2.utils import write_output, read_input, time_memory_tracking


def majority_element(A, left, right):
    if left == right:
        return A[left]

    # массив пополам
    mid = (left + right) // 2
    # ищем элемент большинства в левой и правой половинах
    left_majority = majority_element(A, left, mid)
    right_majority = majority_element(A, mid + 1, right)

    # если оба подмассива возвращают одинаковый элемент
    if left_majority == right_majority:
        return left_majority

    # количество вхождений каждой цифры в текущем подмассиве
    left_count = sum(1 for i in range(left, right + 1) if A[i] == left_majority)
    right_count = sum(1 for i in range(left, right + 1) if A[i] == right_majority)

    # возвращаем элемент
    if left_count > (right - left + 1) // 2:
        return left_majority
    if right_count > (right - left + 1) // 2:
        return right_majority

    # нет подходящего элемента
    return 0


if __name__ == "__main__":
    time_start = time.perf_counter()
    n, arr = read_input("../txtf/input.txt")
    res = majority_element(arr, 0, n - 1)
    if res != 0:
        res = 1
    write_output(str(res))
    time_memory_tracking(time_start)
```

## Результаты

- **Время выполнения:** Время выполнения программы измерялось с помощью модуля `time` и составляет менее 2 секунд для тестовых данных.
- **Использование памяти:** Пиковое потребление памяти не превышает 256 Мб.
- **Элемент большинства:** Программа выводит 1, если существует элемент, который встречается более чем в половине случаев, и 0, если такого элемента нет.
